package ip

import (
	"github.com/google/uuid"
	"github.com/malc0mn/ptp-ip/ip/internal"
	"github.com/malc0mn/ptp-ip/ptp"
)

type DataPhase uint32
type PacketType uint32
type FailReason uint32
type ProtocolVersion uint32

const (
	DP_NoDataOrDataIn DataPhase = 0x00000001
	DP_DataOut        DataPhase = 0x00000002
	DP_Unknown        DataPhase = 0x00000003

	FR_FailRejectedInitiator FailReason = 0x00000001
	FR_FailBusy              FailReason = 0x00000002
	FR_FailUnspecified       FailReason = 0x00000003

	PKT_InitCommandRequest PacketType = 0x00000001
	PKT_InitCommandAck     PacketType = 0x00000002
	PKT_InitEventRequest   PacketType = 0x00000003
	PKT_InitEventAck       PacketType = 0x00000004
	PKT_InitFail           PacketType = 0x00000005
	PKT_OperationRequest   PacketType = 0x00000006
	PKT_OperationResponse  PacketType = 0x00000007
	PKT_Event              PacketType = 0x00000008
	PKT_StartData          PacketType = 0x00000009
	PKT_Data               PacketType = 0x0000000A
	PKT_Cancel             PacketType = 0x0000000B
	PKT_EndData            PacketType = 0x0000000C
	PKT_ProbeRequest       PacketType = 0x0000000D
	PKT_ProbeResponse      PacketType = 0x0000000E

	PV_VersionOnePointZero ProtocolVersion = 0x00010000
)

// This packet is used immediately after the Command/Data TCP ip channel is established. It is sent by the
// Initiator to the Responder on the Data/Command TCP connection and is used to communicate the identity of the
// Initiator to the Responder. The Responder can implement a filtering mechanism denying certain identities.
type InitCommandRequestPacket struct {
	packetType PacketType
	guid uuid.UUID
	// A null terminated string.
	friendlyName string
	// The 16 most significant bits are the major number, the 16 least significant bits are the minor number.
	protocolVersion ProtocolVersion
}

func (icrp *InitCommandRequestPacket) Payload() ([]byte, []byte) {
	p := internal.ToBytesLittleEndian(icrp)
	// The packet length MUST include the header, so we add 4 bytes for the length field!
	length := internal.ToBytesLittleEndian(uint32(len(p) + 4))
	return length, p
}

func NewInitCommandRequestPacket(guid uuid.UUID, friendlyName string) *InitCommandRequestPacket {
	icrp := new(InitCommandRequestPacket)
	icrp.packetType = PKT_InitCommandRequest
	icrp.guid = guid
	icrp.friendlyName = friendlyName
	icrp.protocolVersion = PV_VersionOnePointZero
	return icrp
}

func NewInitCommandRequestPacketWithVersion(guid uuid.UUID, friendlyName string, protocolVersion ProtocolVersion) *InitCommandRequestPacket {
	icrp := NewInitCommandRequestPacket(guid, friendlyName)
	icrp.protocolVersion = protocolVersion
	return icrp
}

// This packet is sent by the Responder in response to an InitCommandRequestPacket, to communicate the assigned
// ConnectionNumber for the PTP-IP session. It is transmitted on Data/Command TCP connection.
type InitCommandAckPacket struct {
	packetType PacketType
	// A unique number generated by the Responder used to associate the TCP ip channels belonging to same PTP-IP
	// session. Reuse this number in the requests that will follow the InitCommandACKPacket.
	ConnectionNumber      uint32
	ResponderGUID         uuid.UUID
	ResponderFriendlyName string // null terminated string
	// The 16 most significant bits are the major number, the 16 least significant bits are the minor number.
	ResponderProtocolVersion uint32
}

// After the Command/Data TCP Connection is established, this packet is used by the Initiator in order to establish the
// Event TCP Connection. When the Initiator receives a valid InitCommandAckPacket it establishes the Event TCP
// connection and transmits this packet on the Event TCP connection. The connection number received via the
// InitCommandAckPacket is reused in this packet.
type InitEventRequestPacket struct {
	packetType PacketType
	ConnectionNumber uint32
}

// This packet is used by the Responder to inform the Initiator that the PTP-IP connection establishment has completed
// successfully. It is transmitted on the Event TCP connection.
type InitEventAckPacket struct {
	packetType PacketType
}

// This packet is used by the Responder to inform the Initiator that the PTP-IP connection establishment failed. The
// reason of failure is reported in the Reason field. Upon receiving the packet, the Initiator MUST close the
// Command/Data TCP Connection with the Responder that rejects the event connection request. After issuing an
// InitFailPacket, the Responder SHALL close the PTP-IP connection (TCP connections initiated from the Initiator that
// has been rejected). The InitFailPacket can be transported on either of the TCP connections.
type InitFailPacket struct {
	packetType PacketType
	Reason FailReason
}

// This packet is used to ip PTP operation requests. PTP-IP Operation Request Packets are issued by the Initiator
// and are transported to the Responder device via the PTP-IP Command/Data ip channel. The direction of this
// packet is from Initiator to Responder.
// If the DataPhaseInfo field is set to DP_DataOut, then this packet MUST be followed by a StartDataPacket.
// If the Initiator wants to transfer a null data object to the Responder, than it has two options:
//   1. Set the DataPhaseInfo field to DP_NoDataOrDataIn, in which case the responder will follow up with an
//      OperationResponsePacket, without waiting for a data.
//   2. Set the DataPhaseInfo field to DP_DataOut. In this case, the data out phase MUST consist of exactly one
//      StartDataPacket, having the TotalDataLength field set to 0x00000000, and one empty EndDataPacket. The
//      Initiator MUST NOT send any other data packets.
type OperationRequestPacket struct {
	packetType PacketType
	DataPhaseInfo DataPhase
	ptp.OperationRequest
}

// This packet is used to ip Operation Responses by the Responder and are transported to the Initiator via the
// Command/Data TCP connection. PTP-IP Operation Response Packets are only issued by the Responder to indicate that the
// requested operation transaction has been completed and to pass the operation result.
type OperationResponsePacket struct {
	packetType PacketType
	ptp.OperationResponse
}

// This packet is used to ip PTP Events on the Event TCP connection. The events are used to inform the Initiator
// about the Responder state change.
type EventPacket struct {
	packetType PacketType
	ptp.Event
}

// This type of packet is used to signal the beginning of a data transfer. It is a is bi-directional packet, so this
// packet is either from the Responder to the Initiator or from the Initiator to the Responder. It is transmitted
// on Command/Data TCP connection.
type StartDataPacket struct {
	packetType PacketType
	TransactionId ptp.TransactionID
	// A value of 0xFFFFFFFFFFFFFFFF indicates that the size of the data is not known at the beginning of the data phase.
	TotalDataLength uint64
}

// This packet is used to ip data. DataPackets are only used during data phase of a transaction and can be
// issued either by the Initiator or Responder in the direction of the data flow:
//   1. for the data-in phase - from the Responder to the Initiator
//   2. for the data-out phase - from the Initiator to the Responder.
// Data Packets are transmitted on Command/Data TCP connection.
// Normally there is no need in doing fragmentation and assembly of large data packets. However, a basic fragmentation
// mechanism MAY be utilized to allow for a simple data transfer cancelling mechanism. No error checking is required.
type DataPacket struct {
	packetType PacketType
	TransactionId ptp.TransactionID
	DataPayload   interface{}
}

// This packet is used to indicate the end of the data phase. The EndDataPacket can also carry useful data. This
// packet is only used during data phase of a transaction and can be issued either by the Initiator or Responder in the
// direction of the data flow: for the data-in phase - from the Responder to the Initiator; for the data-out phase -
// from the Initiator to the Responder.
type EndDataPacket struct {
	packetType PacketType
	TransactionId ptp.TransactionID
	DataPayload   interface{}
}

// This packet is used to cancel a transaction.
type CancelPacket struct {
	packetType PacketType
	TransactionId ptp.TransactionID
}

// This packet can be used by both Initiator and Responder to check if a peer device is still active. Upon receiving
// such packet, the device MUST respond immediately with a ProbeResponsePacket. If no response is received within a
// reasonable period of time, the device initiating this check will close the active PTP-IP session(s) with the remote
// device.
// This packet should be used with utmost care in order to avoid overloading of the LAN.
//   1. Initiator to Responder: it is recommended that this packet is used only during a PTP transaction (e.g. when a
//      format command is issued; if the storage media is large, the response time can be quite large), in order to
//      check out if the Responder is still active or not.
//   2. Responder to Initiator: it is recommended to use this packet only when the Responder receives a request for a
//      new PTP-IP session while one ore more other sessions are active. In this case, the Responder can check if the
//      existing PTP-IP connections are still active.
//   3. It is recommended that a timeout of 10 seconds be set between sending the Probe Request Packet and receiving the
//      Probe Response Packet.
type ProbeRequestPacket struct {
	packetType PacketType
}

// This packet can be used in PTP-IP by both Initiator and Responder, as a response to a ProbeRequestPacket. Upon
// receiving a ProbeRequestPacket, a Probe Response Packet MUST be issued immediately. The Probe Response Packet is
// shown in Figure 20 and it is sent on the Event TCP connection.
type ProbeResponsePacket struct {
	packetType PacketType
}
